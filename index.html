<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OUTER HEAVEN | Tron Race</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            overflow: hidden;
            font-family: 'Orbitron', 'Segoe UI', sans-serif;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .title {
            position: fixed;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff0040;
            font-size: 2.5rem;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 0.5em;
            text-shadow:
                0 0 10px #ff0040,
                0 0 20px #ff0040,
                0 0 40px #ff0040,
                0 0 80px #ff0040;
            animation: flicker 3s infinite;
            z-index: 100;
        }

        .subtitle {
            position: fixed;
            top: 90px;
            left: 50%;
            transform: translateX(-50%);
            color: #00ffff;
            font-size: 0.9rem;
            letter-spacing: 0.3em;
            text-shadow: 0 0 10px #00ffff;
            opacity: 0.8;
            z-index: 100;
        }

        .speed-display {
            position: fixed;
            bottom: 40px;
            right: 40px;
            color: #ff0040;
            font-size: 3rem;
            font-weight: 900;
            text-shadow: 0 0 20px #ff0040;
            z-index: 100;
        }

        .speed-label {
            font-size: 0.8rem;
            color: #666;
            letter-spacing: 0.2em;
        }

        .ai-badge {
            position: fixed;
            bottom: 40px;
            left: 40px;
            color: #00ffff;
            font-size: 0.9rem;
            letter-spacing: 0.2em;
            text-shadow: 0 0 10px #00ffff;
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .ai-badge::before {
            content: 'ðŸ¤–';
            font-size: 1.5rem;
        }

        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.1) 0px,
                rgba(0, 0, 0, 0.1) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 50;
        }

        .vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, transparent 0%, rgba(0,0,0,0.7) 100%);
            pointer-events: none;
            z-index: 40;
        }

        @keyframes flicker {
            0%, 95%, 100% { opacity: 1; }
            96%, 98% { opacity: 0.8; }
            97% { opacity: 0.4; }
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff0040;
            font-size: 1.2rem;
            letter-spacing: 0.3em;
            z-index: 200;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .controls {
            position: fixed;
            top: 50%;
            right: 30px;
            transform: translateY(-50%);
            color: #444;
            font-size: 0.7rem;
            letter-spacing: 0.1em;
            text-align: right;
            z-index: 100;
        }

        .controls div {
            margin: 5px 0;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
</head>
<body>
    <div id="canvas-container"></div>

    <div class="title">OUTER HEAVEN</div>
    <div class="subtitle">AUTONOMOUS AI SYSTEM ONLINE</div>

    <div class="speed-display">
        <span id="speed">0</span>
        <div class="speed-label">KM/H</div>
    </div>

    <div class="ai-badge">
        AI CONTROLLED | NO HUMAN IN THE LOOP
    </div>

    <div class="controls">
        <div>DRAG TO ROTATE</div>
        <div>SCROLL TO ZOOM</div>
    </div>

    <div class="scanlines"></div>
    <div class="vignette"></div>

    <div class="loading" id="loading">INITIALIZING SYSTEM...</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000810);
        scene.fog = new THREE.FogExp2(0x000810, 0.015);

        // Camera
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(8, 4, 8);

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2.1;
        controls.minDistance = 5;
        controls.maxDistance = 20;
        controls.target.set(0, 1, 0);

        // Lights
        const ambientLight = new THREE.AmbientLight(0x111122, 0.5);
        scene.add(ambientLight);

        // Red key light
        const keyLight = new THREE.SpotLight(0xff0040, 3);
        keyLight.position.set(10, 15, 10);
        keyLight.castShadow = true;
        keyLight.shadow.mapSize.width = 2048;
        keyLight.shadow.mapSize.height = 2048;
        scene.add(keyLight);

        // Cyan fill light
        const fillLight = new THREE.SpotLight(0x00ffff, 1.5);
        fillLight.position.set(-10, 10, -10);
        scene.add(fillLight);

        // Red rim light
        const rimLight = new THREE.PointLight(0xff0040, 2, 20);
        rimLight.position.set(0, 3, -5);
        scene.add(rimLight);

        // Tron Grid Floor
        const gridSize = 100;
        const gridDivisions = 50;

        // Main grid
        const gridHelper = new THREE.GridHelper(gridSize, gridDivisions, 0xff0040, 0x330011);
        gridHelper.position.y = 0;
        scene.add(gridHelper);

        // Secondary finer grid
        const gridHelper2 = new THREE.GridHelper(gridSize, gridDivisions * 2, 0x220008, 0x110004);
        gridHelper2.position.y = 0.01;
        scene.add(gridHelper2);

        // Glowing floor plane
        const floorGeometry = new THREE.PlaneGeometry(gridSize, gridSize);
        const floorMaterial = new THREE.MeshBasicMaterial({
            color: 0x000000,
            transparent: true,
            opacity: 0.8
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -0.01;
        floor.receiveShadow = true;
        scene.add(floor);

        // Racing lines (animated)
        const lineMaterial = new THREE.MeshBasicMaterial({
            color: 0xff0040,
            transparent: true,
            opacity: 0.8
        });

        const lines = [];
        for (let i = 0; i < 20; i++) {
            const lineGeometry = new THREE.BoxGeometry(0.1, 0.02, 2 + Math.random() * 3);
            const line = new THREE.Mesh(lineGeometry, lineMaterial.clone());
            line.position.set(
                (Math.random() - 0.5) * 40,
                0.02,
                Math.random() * 50 - 25
            );
            line.userData.speed = 0.5 + Math.random() * 1;
            lines.push(line);
            scene.add(line);
        }

        // Particle system for atmosphere
        const particleCount = 500;
        const particleGeometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount * 3; i += 3) {
            positions[i] = (Math.random() - 0.5) * 50;
            positions[i + 1] = Math.random() * 20;
            positions[i + 2] = (Math.random() - 0.5) * 50;
        }

        particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        const particleMaterial = new THREE.PointsMaterial({
            color: 0xff0040,
            size: 0.05,
            transparent: true,
            opacity: 0.6
        });

        const particles = new THREE.Points(particleGeometry, particleMaterial);
        scene.add(particles);

        // Load the bike
        let bike = null;
        const loader = new THREE.GLTFLoader();

        loader.load(
            'bike.glb',
            function(gltf) {
                bike = gltf.scene;

                // Scale and position
                bike.scale.set(2, 2, 2);
                bike.position.set(0, 0, 0);

                // Apply Tron materials
                bike.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;

                        // Create emissive Tron-style material
                        const originalColor = child.material.color ? child.material.color.getHex() : 0x111111;

                        child.material = new THREE.MeshStandardMaterial({
                            color: 0x111111,
                            metalness: 0.9,
                            roughness: 0.2,
                            emissive: 0xff0040,
                            emissiveIntensity: 0.3
                        });

                        // Make edges glow
                        if (child.geometry) {
                            const edges = new THREE.EdgesGeometry(child.geometry, 15);
                            const edgeMaterial = new THREE.LineBasicMaterial({
                                color: 0xff0040,
                                linewidth: 2
                            });
                            const edgeLines = new THREE.LineSegments(edges, edgeMaterial);
                            child.add(edgeLines);
                        }
                    }
                });

                scene.add(bike);
                document.getElementById('loading').style.display = 'none';
            },
            function(xhr) {
                const progress = Math.round((xhr.loaded / xhr.total) * 100);
                document.getElementById('loading').textContent = `LOADING VEHICLE... ${progress}%`;
            },
            function(error) {
                console.error('Error loading bike:', error);
                document.getElementById('loading').textContent = 'ERROR LOADING VEHICLE';
            }
        );

        // Speed counter animation
        let displaySpeed = 0;
        let targetSpeed = 280;

        function updateSpeed() {
            if (displaySpeed < targetSpeed) {
                displaySpeed += Math.random() * 5;
                if (displaySpeed > targetSpeed) displaySpeed = targetSpeed;
            }
            // Add some fluctuation
            const fluctuation = Math.sin(Date.now() * 0.005) * 10;
            document.getElementById('speed').textContent = Math.round(displaySpeed + fluctuation);
        }

        // Animation loop
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.016;

            controls.update();

            // Animate bike hover
            if (bike) {
                bike.position.y = Math.sin(time * 2) * 0.1 + 0.1;
                bike.rotation.y = Math.sin(time * 0.5) * 0.05;
            }

            // Animate racing lines
            lines.forEach(line => {
                line.position.z -= line.userData.speed;
                if (line.position.z < -25) {
                    line.position.z = 25;
                    line.position.x = (Math.random() - 0.5) * 40;
                }
                line.material.opacity = 0.3 + Math.sin(time * 5 + line.position.x) * 0.2;
            });

            // Animate particles
            const positions = particles.geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                positions[i + 2] -= 0.1;
                if (positions[i + 2] < -25) {
                    positions[i + 2] = 25;
                }
            }
            particles.geometry.attributes.position.needsUpdate = true;

            // Pulse lights
            rimLight.intensity = 2 + Math.sin(time * 3) * 0.5;

            updateSpeed();

            renderer.render(scene, camera);
        }

        animate();

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
